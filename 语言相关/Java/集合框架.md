1. 什么是集合？

   集合是Java提供的数据结构和算法的api。不需要像C一样另造轮子，就能使用数据结构和算法了。

   ​

2. Collection接口

    ![Collection类图](../pics/Collection类图.png)

   ![](https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495614959696503.png)

3. List

   ![](https://www.sxt.cn/360shop/Public/admin/UEditor/20170524/1495616109914665.png)

   - ArrayList:
     ```java
        package jihe.list;

        /**
         * 手写ArrayList
         * 底层维护了数组，增删效率低，查询效率高
         * @author xiasj
         *
         */
        public class TestArrayList<E> {

        	//List维护此数组
        	private Object[] elementData;
        	private int size;
        	//如果New一个新的ArrayList但是没指定默认大小，则设为10
        	private static final int DEFALT_CAPACITY=10;
        	/**
        	 * 构造
        	 */
        	public TestArrayList() {
        		elementData=new Object[DEFALT_CAPACITY];
        	}
        	public TestArrayList(int capacity) {
        		if(capacity<0) {
        			throw new RuntimeException("容量不合法"+capacity);
        		}else if(capacity==0){
        			elementData=new Object[DEFALT_CAPACITY];
        		}
        		elementData=new Object[capacity];
        	}

        	/**
        	 * get
        	 */
        	public E get(int index) {
        		return (E)elementData[index];
        	}
        	/**
        	 * set
        	 */
        	public void set(E element,int index) {

        		//对索引index判断
        		if(size<0 || index>size-1) {
        			throw new RuntimeException("索引不合法"+index);
        		}
        		elementData[index]=element;
        	}
        	/**
        	 * 扩容
        	 * @param element
        	 */
        	public void add(E element) {
        		//什么时候扩容
        		if(size==elementData.length) {
        			//扩容
        			Object[] newArray=new Object[elementData.length+(elementData.length>>1)];//x>>n=x/(2^n)
        			System.arraycopy(elementData, 0, newArray, 0, elementData.length);
        			elementData=newArray;

        		}
        		elementData[size++]=element;
        	}

        	/**
        	 * remove
        	 * 会完成自己给自己拷贝，把index后面的元素都拷贝一遍，所以效率低
        	 */
        	public void remove(E element) {
        		//将element和所有元素比较，第一个为true的，返回
        		for (int i = 0; i < size; i++) {
        			if(element.equals(get(i))) {

        				//将该元素从此处移除
        				remove(i);
        			}
        		}

        	}

        	public void remove(int index) {
        		//A B C D 删除1位置的B
        		//A C D 会完成自己给自己拷贝，把index后面的元素都拷贝一遍，所以效率低
        		if(elementData.length-index-1>0) {
        			System.arraycopy(elementData, index+1, elementData, index, elementData.length-index-1);
        		}

        		elementData[--size]=null;

        	}

        	@Override
        	public String toString() {
        		StringBuilder sb=new StringBuilder();

        		sb.append("[");
        		for(int i=0;i<size;i++) {
        			sb.append(elementData[i]+",");
        		}
        		sb.setCharAt(sb.length()-1,']');

        		return sb.toString();

        	}
        	public static void main(String[] args) {
        		TestArrayList<String> tl=new TestArrayList<String>();
        		for (int i = 0; i <100; i++) {
        			tl.add("text"+i);
        		}
        		tl.set("xxx", 1);
        		System.out.println(tl);

        		tl.remove(1);
        		System.out.println(tl);
        	}
        }

     ```
   - LinkedList:
     ```java
     package jihe.list;

     import javax.management.RuntimeErrorException;

     /**
      * 为双向链表：查询效率低，增删效率高线程不安全
      * 每个节点有
      * class  Node {
     		Node  previous;	  //前一个节点
     		Object  element;    //本节点保存的数据
     		Node  next;		  //后一个节点
        }
        删除ax就把ax-1的next指向ax+1，ax+1的previous指向ax-1
      *
      * @author xiasj
      *
      */
     public class TestLinkedList<E> {

     	private Node first;
     	private Node last;

     	private int size;

     	public TestLinkedList() {


     	}


     	/**
     	 * get
     	 * @param index
     	 * @return
     	 */
     	public E get(int index) {
     		checkIndex(index);
     		return getNode(index)!=null?(E)getNode(index).element:null;

     	}
     	/**
     	 *
     	 * @param index
     	 */
     	private void checkIndex(int index) {
     		if(index<0 || index>size-1) {
     			throw new RuntimeException("index不合法");
     		}
     	}
     	/**
     	 * getNode得到制定节点
     	 */
     	public Node getNode(int index) {
     		checkIndex(index);
     		Node temp=first;
     		//遍历节点直到index位置的节点然后返回，二分法
     		if(index<size>>1) {
     			for (int i = 0; i < index; i++) {
     				temp=temp.next;
     			}
     		}else{
     			temp=last;
     			for (int i = size-1; i > index; i--) {
     				temp=temp.previous;
     			}
     		}
     		return temp;
     	}

     	/**
     	 * add
     	 *
     	 */
     	public void add(int index,E element) {
     		checkIndex(index);
     		Node newNode =new Node(element);
     		Node temp= getNode(index);
     		if(temp!=null && index!=0 && index!=size-1) {
     			Node pre=temp.previous;
     			Node nex=temp.next;
     			pre.next=newNode;
     			newNode.previous=pre;

     			newNode.next=temp;
     			temp.previous=newNode;

     		}
     		if(index==0){
     			newNode.next=temp;
     			first=newNode;
     			temp.previous=newNode;
     			System.out.println(temp.previous);
     		}else if (index==size-1) {
     			newNode.previous=temp;
     			last=newNode;
     			temp.next=newNode;
     		}
     		size++;
     	}

     	// ["a","b"]加入["c"]或[]加入["c"]
     	public void add(E element) {
     		Node node =new Node(element);
     		//如果没有节点，那么first和last都是我node
     		if(first==null) {
     			first =node;
     			last=node;

     		}else {
     			//如果新加节点内容为node("c")，那么这个新节点的previous=最后一个last("b")
     			node.previous=last;
     			//新节点的下一个为null
     			node.next=null;

     			//原来的last指向新节点node("c")，新节点再换成last节点
     			last.next=node;
     			last=node;


     		}
     		size++;
     	}
     	/**
     	 * remove
     	 */
     	public void remove(int index) {
     		checkIndex(index);
     		Node temp=getNode(index);

     		if(temp!=null) {
     			Node pre=temp.previous;
     			Node nex=temp.next;
     			if(pre!=null) {
     				pre.next=nex;

     			}
     			if(nex!=null) {
     				nex.previous=pre;
     			}

     			if(index==0){
     				first=nex;
     			}else if (index==size-1) {
     				last=pre;
     			}


     			size--;
     		}
     	}
     	/**
     	 * 重写toString
     	 * @param args
     	 * @return
     	 */
     	public String toString() {
     		StringBuilder sb=new StringBuilder("[");
     		Node temp=first;
     		while(temp!=null) {
     			sb.append(temp.element+",");
     			temp=temp.next;
     		}
     		sb.setCharAt(sb.length()-1, ']');
     		return sb.toString();
     	}

     	public static void main(String[] args) {
     		TestLinkedList<String> ll=new TestLinkedList<String>();
     		ll.add("a");
     		ll.add("b");
     		ll.add("c");
     		ll.add("d");
     		ll.add("e");
     		System.out.println(ll.toString()+" "+ll.size);
     		ll.remove(3);
     		System.out.println(ll.toString()+" "+ll.size);
     		ll.remove(3);
     		System.out.println(ll.toString()+" "+ll.size);
     		ll.add(0,"a1");
     		ll.add(3,"a1");
     		System.out.println(ll.toString()+" "+ll.size);
     	}
     }

     ```
   - Vector:
     Vector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”。

